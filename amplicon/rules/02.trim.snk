def get_fastq(wildcards, samples, read_pair="fq1"):
    return samples.loc[wildcards.sample, [read_pair]]

"""
rule flexbar_trim:
    input:
        read1 = lambda wildcards: get_fastq(wildcards, samples, "fq1"),
        read2 = lambda wildcards: get_fastq(wildcards, samples, "fq2")
        #fastqc = os.path.join(config["result"]["fastqc"], "fastqc_multiqc_report.html")
    output:
        outfile = expand("{trim}/{{sample}}_{read}.fastq.gz",
                        trim=config["result"]["trim"],
                        read=["1", "2"])
    params:
        prefix  = os.path.join(config["result"]["trim"], "{sample}"),
        ao      = config["params"]["trim"]["ao"],
        quality = config["params"]["trim"]["quality"],
        min_length  = config["params"]["trim"]["min_length"],
        threads     = config["params"]["trim"]["cpu"],
        max_uncall  = config["params"]["trim"]["max_uncalled"],
        adapter     = config["params"]["trim"]["adapter"]
    log:
        os.path.join(config["logs"]["trim"], "trim_{sample}.log")
    shell:
        '''
        flexbar -a {params.adapter}\
            -ao {params.ao} -qt {params.quality} \
            --min-read-length {params.min_length} \
            --threads {params.threads} \
            --zip-output GZ \
            --max-uncalled {params.max_uncall} \
            -r {input.read1} \
            -p {input.read2}  \
            --target {params.prefix}  2>{log}
        '''

rule trimmomatic_trim:
    input:
        read1 = lambda wildcards: get_fastq(wildcards, samples, "fq1"),
        read2 = lambda wildcards: get_fastq(wildcards, samples, "fq2")
        #fastqc = os.path.join(config["result"]["fastqc"], "fastqc_multiqc_report.html")
    output:
        forward_pair   = expand("{trim}/{{sample}}_1_paired.fq.gz",
                                  trim=config["result"]["trim"]),
        forward_unpair = expand("{trim}/{{sample}}_1_unpaired.fq.gz",
                                  trim=config["result"]["trim"]),
        reverse_pair   = expand("{trim}/{{sample}}_2_paired.fq.gz",
                                  trim=config["result"]["trim"]),
        reverse_unpair = expand("{trim}/{{sample}}_2_unpaired.fq.gz",
                                  trim=config["result"]["trim"])
    params:
        mismatch = config["params"]["trim"]["mismatch"],
        quality  = config["params"]["trim"]["quality"],
        min_length  = config["params"]["trim"]["min_length"],
        min_trim_seq  = config["params"]["trim"]["min_trim_seq"],
        adapter     = config["params"]["trim"]["adapter"]
    log:
        os.path.join(config["logs"]["trim"], "trim_{sample}.log")
    shell:
        '''
        trimmomatic PE {input.read1} {input.read2} \
            {output.forward_pair} {output.forward_unpair} {output.reverse_pair} {output.reverse_unpair} \
            ILLUMINACLIP:{params.adapter}:{params.mismatch}:{params.quality}:10:{params.min_trim_seq}:keepBothReads \
            SLIDINGWINDOW:15:20 LEADING:3 TRAILING:3 MINLEN:{params.min_length} 2>{log}
        '''
"""

rule cutadapt_trim:
    input:
        read1 = lambda wildcards: get_fastq(wildcards, samples, "fq1"),
        read2 = lambda wildcards: get_fastq(wildcards, samples, "fq2")
    output:
        r1 = expand("{trim}/{{sample}}_1_trimmed.fq.gz", trim=config["result"]["trim"]),
        r2 = expand("{trim}/{{sample}}_2_trimmed.fq.gz", trim=config["result"]["trim"])
    params:
        prefix  = os.path.join(config["result"]["trim"], "{sample}"),
        quality = config["params"]["trim"]["quality"],
        min_length  = config["params"]["trim"]["min_length"],
        f_adapter     = config["params"]["trim"]["f_adapter"],
        r_adapter     = config["params"]["trim"]["r_adapter"]
    log:
        os.path.join(config["logs"]["trim"], "trim_{sample}.log")
    shell:
        '''
        cutadapt -g {params.f_adapter} -G {params.r_adapter} \
            -o {output.r1} -p {output.r2} \
            {input.read1} {input.read2} \
            -q {params.quality} \
            -l {params.min_length} 2>{log}
        '''